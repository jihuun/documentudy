<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Documentudy</title>
    <description></description>
    <link>http://localhost:4000/documentudy/</link>
    <atom:link href="http://localhost:4000/documentudy/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 06 Sep 2021 20:04:37 +0900</pubDate>
    <lastBuildDate>Mon, 06 Sep 2021 20:04:37 +0900</lastBuildDate>
    <generator>Jekyll v3.4.0</generator>
    
      <item>
        <title>Publishing my project to Homebrew</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1-개요&quot; id=&quot;markdown-toc-1-개요&quot;&gt;1. 개요&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-homebrew에-프로젝트-등록하기&quot; id=&quot;markdown-toc-2-homebrew에-프로젝트-등록하기&quot;&gt;2. Homebrew에 프로젝트 등록하기&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#21--내-프로젝트-바이너리-생성-및-release&quot; id=&quot;markdown-toc-21--내-프로젝트-바이너리-생성-및-release&quot;&gt;2.1.  내 프로젝트 바이너리 생성 및 release&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#22-homebrew-rsdic-github-repo-생성&quot; id=&quot;markdown-toc-22-homebrew-rsdic-github-repo-생성&quot;&gt;2.2. &lt;code class=&quot;highlighter-rouge&quot;&gt;homebrew-rsdic&lt;/code&gt; Github repo 생성&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-패키지-설치해보기&quot; id=&quot;markdown-toc-3-패키지-설치해보기&quot;&gt;3. 패키지 설치해보기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#4-추후-릴리즈-자동화&quot; id=&quot;markdown-toc-4-추후-릴리즈-자동화&quot;&gt;4. 추후 릴리즈 자동화&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1-개요&quot;&gt;1. 개요&lt;/h1&gt;
&lt;p&gt;UNIX 계열 운영체제는 각각 여러가지 Package Manager가 존재한다. 우분투 같은 Debian 계열의 리눅스 배포판은 &lt;a href=&quot;https://www.debian.org/doc/manuals/debian-reference/ch02.en.html&quot;&gt;APT-based&lt;/a&gt; package management 도구를 제공한다. Red Hat계열의 리눅스 배포판에서는 &lt;a href=&quot;https://rpm.org/&quot;&gt;RPM&lt;/a&gt;이라는 Package Manager를 제공한다. Package Manager 종류에 대한 자세한 내용은 &lt;a href=&quot;https://en.wikipedia.org/wiki/List_of_software_package_management_systems&quot;&gt;위키피디아 문서&lt;/a&gt;를 참고. MacOS 에서는 Homebrew라는Package Manager를 많이 사용하는데. Homebrew에 내가만든 소프트웨어를 Publish하여 사람들이 쉽게 내 소프트웨어를 다운받고 설치할수 있게 만들어보자. 내가 조사한 바로는 아래와 같이 두 가지 방법이 있다.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Homebrew-core 에 등록&lt;/strong&gt;&lt;br /&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;brew install &amp;lt;my-project&amp;gt;&lt;/code&gt; 로 설치가능하게 되는 공식적인 방법. &lt;a href=&quot;https://github.com/Homebrew/homebrew-core&quot;&gt;homebrew-core github repo&lt;/a&gt;에 &lt;a href=&quot;https://github.com/Homebrew/homebrew-core/pulls&quot;&gt;Pull Request&lt;/a&gt;를 보내면 되는듯 하다. 자세한 내용은 다음의 Documentation를 참고하면 된다. &lt;a href=&quot;https://docs.brew.sh/Adding-Software-to-Homebrew&quot;&gt;Adding-Software-to-Homebrew&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Brew tap 으로 설치&lt;/strong&gt;&lt;br /&gt;
homebrew 공식 릴리즈에 포함되지 않더라도 등록할 수 있는 방법이다. 결과는 brew tap 으로 repo를 추가할수 있게된다. 참고로 Tap 은 homebrew에서 제공하는 third-party 저장소를 등록하는 방법이다. 등록 이후에 아래와 같은 방법으로 해당 소프트웨어를 설치 할 수 있다. 참고 문서: &lt;a href=&quot;https://federicoterzi.com/blog/how-to-publish-your-rust-project-on-homebrew/&quot;&gt;https://federicoterzi.com/blog/how-to-publish-your-rust-project-on-homebrew/&lt;/a&gt;&lt;/p&gt;
    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew tap jihuun/rsdic
  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew install rsdic
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;이 문서에서는 2번 방법에대해 알아볼 것이다. 예제로 사용한 Publish 대상은 내가 만든 터미널용 영어사전인 &lt;a href=&quot;https://github.com/jihuun/rsdic&quot;&gt;rsdic&lt;/a&gt;이다. 이 프로젝트는 Rust로 작성되었으며 이 문서에는 Rust 관련 내용이 일부 포함될 수 있다.&lt;/p&gt;

&lt;h1 id=&quot;2-homebrew에-프로젝트-등록하기&quot;&gt;2. Homebrew에 프로젝트 등록하기&lt;/h1&gt;

&lt;h2 id=&quot;21--내-프로젝트-바이너리-생성-및-release&quot;&gt;2.1.  내 프로젝트 바이너리 생성 및 release&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;*.tar.gz&lt;/code&gt; 압축파일 생성&lt;/strong&gt;&lt;br /&gt;
조금 뒤에 살펴볼 homebrew &lt;code class=&quot;highlighter-rouge&quot;&gt;Formula&lt;/code&gt;에서 *.tar.gz 로 압축된 바이너리를 필요로한다. 우선 프로젝트를 빌드하여 실행파일을 생성한 뒤에 *.tar.gz로 압축 하면된다. Rust에서는 &lt;code class=&quot;highlighter-rouge&quot;&gt;cargo build --release&lt;/code&gt; 하면 쉽게 릴리즈 바이너리를 빌드할 수 있다.&lt;/p&gt;

    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  cargo build --release
  &lt;span class=&quot;nb&quot;&gt;cd &lt;/span&gt;target/release
  tar -zcvf rsdic.tar.gz rsdic
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;sha256 해시 생성&lt;/strong&gt; &lt;br /&gt;
생성한 압축파일에 대한 해시값도 추후 homebrew &lt;code class=&quot;highlighter-rouge&quot;&gt;Formula&lt;/code&gt;에 추가해야 한다. 빠르게 검색하기 위한 용도인듯 하다.&lt;/p&gt;

    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;shasum -a 256 rsdic.tar.gz
  f65f3265654fd662fd37334122cd2f97f3b85de12969dae81d0484f30cebeceb  rsdic.tar.gz
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;바이너리 링크 생성&lt;/strong&gt;&lt;br /&gt;
Github Release에 &lt;my-project&gt;.tar.gz  바이너리 업로드 하고 아래와 같은 링크를 생성한다.
https://github.com/jihuun/rsdic/releases/download/v0.1.0/rsdic.tar.gz&lt;/my-project&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;22-homebrew-rsdic-github-repo-생성&quot;&gt;2.2. &lt;code class=&quot;highlighter-rouge&quot;&gt;homebrew-rsdic&lt;/code&gt; Github repo 생성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;homebrew-rsdic&lt;/code&gt; Github repo 생성&lt;/strong&gt; &lt;br /&gt;
Github repository를 하나 생성한다. 저장소 이름은 &lt;code class=&quot;highlighter-rouge&quot;&gt;homebrew-&amp;lt;projectname&amp;gt;&lt;/code&gt; 와 같은 방식으로 해야한다. 자세한 이유는 &lt;a href=&quot;https://docs.brew.sh/Taps#repository-naming-conventions-and-assumptions&quot;&gt;Homebrew 네이밍 컨벤션&lt;/a&gt; 참고.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Formula&lt;/code&gt; 작성&lt;/strong&gt; &lt;br /&gt;
Formula는 Ruby 파일인데 딱히 Ruby지식을 필요로 하지는 않는다(나도 모름). 생성한 repository는 아래와 같은 디렉터리 구조를 필요로 한다.&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  - Formula/
      - &amp;lt;projectname&amp;gt;.rb
  - README.md
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Formula/rsdic.rb 생성&lt;/strong&gt;&lt;br /&gt;
Formula/rsdic.rb 파일을 생성하고 아래의 내용을 추가한다.&lt;/p&gt;

    &lt;div class=&quot;language-rb highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  &lt;span class=&quot;c1&quot;&gt;# Documentation: https://docs.brew.sh/Formula-Cookbook&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;#                https://rubydoc.brew.sh/Formula&lt;/span&gt;
  &lt;span class=&quot;c1&quot;&gt;# PLEASE REMOVE ALL GENERATED COMMENTS BEFORE SUBMITTING YOUR PULL REQUEST!&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Rsdic&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&quot;no&quot;&gt;Formula&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;desc&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;A eng-kor dictionary for the terminal users&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;homepage&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://github.com/jihuun/rsdic&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;url&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;https://github.com/jihuun/rsdic/releases/download/v0.1.0/rsdic.tar.gz&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;sha256&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;f65f3265654fd662fd37334122cd2f97f3b85de12969dae81d0484f30cebeceb&quot;&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;version&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;0.1.0&quot;&lt;/span&gt;

    &lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;install&lt;/span&gt;
      &lt;span class=&quot;n&quot;&gt;bin&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;install&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;rsdic&quot;&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;commit  생성하고 push&lt;/strong&gt;&lt;br /&gt;
여기까지 하면 Homebrew를 통해 내 프로젝트를 다운로드 받을 수 있다. 실제 커밋 참고. &lt;a href=&quot;https://github.com/jihuun/homebrew-rsdic/commit/a02f6db3f50a5111ade52e2f31f3c963f97db844&quot;&gt;https://github.com/jihuun/homebrew-rsdic/commit/a02f6db3f50a5111ade52e2f31f3c963f97db844&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-패키지-설치해보기&quot;&gt;3. 패키지 설치해보기&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;brew tap&lt;/code&gt; 으로 third party repo등록&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew tap jihuun/rsdic

  &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&amp;gt; Tapping jihuun/rsdic
  Cloning into &lt;span class=&quot;s1&quot;&gt;'/usr/local/Homebrew/Library/Taps/jihuun/homebrew-rsdic'&lt;/span&gt;...
  remote: Enumerating objects: 5, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
  remote: Counting objects: 100% &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;5/5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
  remote: Compressing objects: 100% &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;4/4&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
  remote: Total 5 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;delta 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, reused 5 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;delta 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, pack-reused 0
  Unpacking objects: 100% &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;5/5&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, &lt;span class=&quot;k&quot;&gt;done&lt;/span&gt;.
  Tapped 1 formula &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;29 files, 24.2KB&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;strong&gt;Package install&lt;/strong&gt;&lt;/p&gt;

    &lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;   &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;brew install rsdic

  &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&amp;gt; Installing rsdic from jihuun/rsdic
  &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&amp;gt; Downloading https://github.com/jihuun/rsdic/releases/download/v0.1.0/rsdic.tar.gz
  &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&amp;gt; Downloading from https://github-releases.githubusercontent.com/364442112/3c316f00-adc4-11eb-88cd-b249eab44c28?X-Amz-Algorithm&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;AWS4-HMAC-SHA256&amp;amp;X-Amz-Crede
&lt;span class=&quot;c&quot;&gt;######################################################################## 100.0%&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;4-추후-릴리즈-자동화&quot;&gt;4. 추후 릴리즈 자동화&lt;/h1&gt;
&lt;p&gt;이제 새 버전 릴리즈시 homebrew-rsdic repo에서 rsdic.rb 파일에 내용을 업데이트 하여 반영하면 된다. Travis 같은 CI/CD 툴로 버전 릴리즈후 brew에 바이너리 업데이트 과정을 자동화 하면 좋을 것 같다.&lt;/p&gt;

</description>
        <pubDate>Sun, 05 Sep 2021 22:00:00 +0900</pubDate>
        <link>http://localhost:4000/documentudy/2021/09/05/publishing-myproject-to-homebrew/</link>
        <guid isPermaLink="true">http://localhost:4000/documentudy/2021/09/05/publishing-myproject-to-homebrew/</guid>
        
        <category>UNIX</category>
        
        <category>Shell</category>
        
        <category>Package_Magager</category>
        
        
        <category>UNIX</category>
        
      </item>
    
      <item>
        <title>Bash Auto Completion</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#개요&quot; id=&quot;markdown-toc-개요&quot;&gt;개요&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#목표&quot; id=&quot;markdown-toc-목표&quot;&gt;목표&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#기초&quot; id=&quot;markdown-toc-기초&quot;&gt;기초&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#complete-명령-사용법&quot; id=&quot;markdown-toc-complete-명령-사용법&quot;&gt;complete 명령 사용법&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#comp_cword-와-comp_words로--인자-다루기&quot; id=&quot;markdown-toc-comp_cword-와-comp_words로--인자-다루기&quot;&gt;COMP_CWORD 와 COMP_WORDS로  인자 다루기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#compreply-전역변수-사용하기&quot; id=&quot;markdown-toc-compreply-전역변수-사용하기&quot;&gt;COMPREPLY 전역변수 사용하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#compgen-사용하기&quot; id=&quot;markdown-toc-compgen-사용하기&quot;&gt;compgen 사용하기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#최종-완성&quot; id=&quot;markdown-toc-최종-완성&quot;&gt;최종 완성&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#references&quot; id=&quot;markdown-toc-references&quot;&gt;References&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;개요&quot;&gt;개요&lt;/h1&gt;
&lt;p&gt;bash 쉘에서 본인이 작성한 스크립트나 프로그램 명령에 argument를 입력할때 TAB으로 자동완성 시켜주는 기능 만들어보자&lt;/p&gt;

&lt;h1 id=&quot;목표&quot;&gt;목표&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;cdd 전달인자인 경로 자동완성기능 추가하기
cdd는 &lt;code class=&quot;highlighter-rouge&quot;&gt;cd ../../../../&lt;/code&gt; 를 입력하는 대신 &lt;code class=&quot;highlighter-rouge&quot;&gt;cdd 4&lt;/code&gt;로 손쉽게 뒤로이동 하는 내가 만든 명령도구다.
&lt;a href=&quot;https://github.com/scriptworld/cdd&quot;&gt;cdd 바로가기&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cdd 3&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt; -&amp;gt;  ../../../ 경로의 디렉터리 이름 출력 및 prefix로 디렉터리 자동완성&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;기초&quot;&gt;기초&lt;/h1&gt;
&lt;p&gt;bash completion 을 만들때, 기본적으로 이 두가지 외부 툴(명령)이 함께 사용된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;complete&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;compgen&lt;/code&gt;
그리고 내부 변수 &lt;code class=&quot;highlighter-rouge&quot;&gt;COMPREPLY&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;COMP_CWORD&lt;/code&gt;,  &lt;code class=&quot;highlighter-rouge&quot;&gt;COMP_WORDS&lt;/code&gt; 를 활용한다. 
이들을 잘 조합한 bash스크립트로 자동완성 기능을 만들 수 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;강추 문서 https://mug896.github.io/bash-shell/command_completion.html&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;complete-명령-사용법&quot;&gt;complete 명령 사용법&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;complete -F &amp;lt;함수&amp;gt; &amp;lt;명령&amp;gt;&lt;/code&gt; : 쉘에서&lt;명령&gt; 작성 후 한칸 띄고 `TAB`치면 &lt;함수&gt; 호출됨. 엔터가 아니라 탭을 쳤을때 사용되는 추가 명령(?) 이라고 보면 될것같음.&lt;/함수&gt;&lt;/명령&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;cdd/completion/bash_cdd 생성&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

_cdd&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'auto completion test'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;complete&lt;/span&gt; -F _cdd cdd 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;심볼릭링크 생성 (MacOS: /usr/local/etc/bash_completion.d)&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;ln -s ~/project/cdd/completions/bash_cdd /usr/local/etc/bash_completion.d/cdd
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;source&lt;/span&gt; /usr/local/etc/bash_completion.d/cdd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;그 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;cdd 3&lt;/code&gt; + &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt;하면 작성한 _cdd 함수가 동작하는것을 알 수 있음. 따라서 앞으로 _cdd() 함수에 원하는 동작을 작성하면 됨.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cdd 3 auto completion test

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;그 뒤 엔터를 치면 실제 cdd명령 수행됨 &lt;code class=&quot;highlighter-rouge&quot;&gt;go to ./../../../ &lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;complete &lt;code class=&quot;highlighter-rouge&quot;&gt;-o dirnames&lt;/code&gt; 옵션&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;TAB 하면 디렉터리 이름을 자동완성 한다.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ complete -o dirnames hello 
$ hello [TAB]
aa/ bb/ cc/
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;-o nospace&lt;/code&gt; 옵션
이름을 자동완성하고 나면 다음 이름을 위해 공백을 띄우게 되는데, 이 옵션은 그걸 방지.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ complete -o nospace -W 'aaa= bbb= ccc='  hello

# 이름을 완성하고 나서 공백을 띄우지 않는다.
$ hello aaa=[stop]
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h1 id=&quot;comp_cword-와-comp_words로--인자-다루기&quot;&gt;COMP_CWORD 와 COMP_WORDS로  인자 다루기&lt;/h1&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int main(int argc, char *argv[])&lt;/code&gt; 의 인자와 동일한 역할&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$COMP_CWORD&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;int argc&lt;/code&gt;  argument 갯수
&lt;code class=&quot;highlighter-rouge&quot;&gt;$COMP_WORDS&lt;/code&gt; -&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;char *argv[]&lt;/code&gt;  모든 argument 문자열 리스트&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt; 을 칠때, cdd명령으로 전달되는 인자 확인&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

_cdd&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;''&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'argument count : '&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$COMP_CWORD&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'argument words0 : '&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COMP_WORDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[0]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'argument words1 : '&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COMP_WORDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[1]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;'argument words2 : '&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COMP_WORDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[2]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;complete&lt;/span&gt; -F _cdd cdd 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cdd 3 
argument count : 2
argument words0 : cdd
argument words1 : 3
argument words2 : 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cdd 3 &lt;/code&gt; space를 치고 &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt;을 친 경우임. 만약 &lt;code class=&quot;highlighter-rouge&quot;&gt;cdd 3&lt;/code&gt; 뒤에 space를 치지 않고 &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt;을 치면 argument count : 1 이 된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;compreply-전역변수-사용하기&quot;&gt;COMPREPLY 전역변수 사용하기&lt;/h1&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt;을 쳤을때 COMPREPLY에 저장된 문자열로 대체된다. 우리가 최종에 값을 저장해야할 변수. bash_completion의 내장 변수.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;#!/bin/bash&lt;/span&gt;

_cdd&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nv&quot;&gt;COMPREPLY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'aabbcc'&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;complete&lt;/span&gt; -F _cdd cdd 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;그 뒤 cdd + &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt;을 하면 aabbcc가 자동으로 대체된다. 
아무문자를 입력하고 &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt;해도 바뀐다. 가령 $ cdd ef&lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt; 하면 -&amp;gt; $ cdd aabbcc 로 바뀜&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;따라서 cdd 뒤에 오는 인자에 따라 COMPREPLY 값을 바꿔주면 될듯!&lt;/p&gt;

&lt;p&gt;가령 cdd 3 하고 (스페이스를 치지 않고 바로) &lt;code class=&quot;highlighter-rouge&quot;&gt;TAB&lt;/code&gt;을 치면, 아직 인자를  전달한것이 아니기 때문에 &lt;code class=&quot;highlighter-rouge&quot;&gt;$COMP_CWORD&lt;/code&gt; 이 &lt;code class=&quot;highlighter-rouge&quot;&gt;2&lt;/code&gt;가 아니라 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&lt;/code&gt;이다. 하지만 작성중인 인자 3은 &lt;code class=&quot;highlighter-rouge&quot;&gt;${COMP_WORDS[1]}&lt;/code&gt; 에 저장되어 있다.&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;argument count : 1
argument words0 : cdd
argument words1 : 3&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;이를 이용하면 ${COMP_WORDS[1]가 &lt;code class=&quot;highlighter-rouge&quot;&gt;3&lt;/code&gt;인 경우에, COMPREPLY에 “../../../”을 저장하면, &lt;code class=&quot;highlighter-rouge&quot;&gt;$ cdd ../../../&lt;/code&gt; 로 대체되게 만들수 있다! 그리고 내부적으로 ../../../ 경로의 실제 디렉터리를 자동완성으로 출력하거나 변환하면 된다. (하지만 현재 cdd 로는 이 기능 수행못함, cdd명령 추가구현 필요)&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;cdd 내부 동작 수정해야할 내용&lt;/p&gt;
  &lt;ol&gt;
    &lt;li&gt;cdd 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;숫자&lt;/code&gt;들어오는 경우 -&amp;gt; 기존 cdd내용 수행&lt;/li&gt;
    &lt;li&gt;cdd 인자로 &lt;code class=&quot;highlighter-rouge&quot;&gt;경로&lt;/code&gt;들어오는 경우 -&amp;gt; 일반 &lt;code class=&quot;highlighter-rouge&quot;&gt;cd 경로&lt;/code&gt; 수행
참고: 숫자 문자 구분 방법: https://stackoverflow.com/questions/806906/how-do-i-test-if-a-variable-is-a-number-in-bash/806923
숫자/문자로 구분하는게 아니라 전달받은 인자가 exist한 directory인지 아닌지로 구분이 더 나을듯?&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;compgen-사용하기&quot;&gt;compgen 사용하기&lt;/h1&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;compgen&lt;/span&gt; -W &lt;span class=&quot;s1&quot;&gt;'단어1 단어2 ... 단어N'&lt;/span&gt; -- &lt;span class=&quot;s2&quot;&gt;&quot;&amp;lt;Prefix&amp;gt;&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;단어 중에서 &lt;Prefix&gt;가 포함 되어있는 단어만 출력한다.&lt;/Prefix&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compgen&lt;/span&gt; -W &lt;span class=&quot;s1&quot;&gt;'soopsaram soopnorm great man'&lt;/span&gt; -- &lt;span class=&quot;s1&quot;&gt;'soop'&lt;/span&gt;
soopsaram
soopnorm

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;ls
complate/   &lt;span class=&quot;nb&quot;&gt;test&lt;/span&gt;/   aa   bb
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;compgen&lt;/span&gt; -W &lt;span class=&quot;s1&quot;&gt;'$(find . -mindepth 1 -maxdepth 1 -type d)'&lt;/span&gt; -- &lt;span class=&quot;s2&quot;&gt;&quot;./co&quot;&lt;/span&gt;
complate/ 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;compgen을 find와 조합해서 디렉터리에 존재하는 경로명을 추출할 수 있다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;최종-완성&quot;&gt;최종 완성&lt;/h1&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_cdd&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COMP_CWORD&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; -eq 1 &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;||&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;0
	&lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; -z &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COMP_WORDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[1]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;COMPREPLY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;__cdd_prev_path 1&lt;span class=&quot;k&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
	&lt;span class=&quot;o&quot;&gt;[[&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COMP_WORDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[1]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;~ ^[0-9]+&lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]]&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
		&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;COMPREPLY&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;$(&lt;/span&gt;__cdd_prev_path &lt;span class=&quot;k&quot;&gt;${&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;COMP_WORDS&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[1]&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;})&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;complete&lt;/span&gt; -o dirnames -o nospace -F _cdd cdd
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;hr /&gt;

&lt;h1 id=&quot;references&quot;&gt;References&lt;/h1&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://z-wony.tistory.com/3&quot;&gt;끄적끄적 프로그래밍&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.tuwlab.com/ece/29643&quot;&gt;https://www.tuwlab.com/ece/29643&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html&quot;&gt;https://www.gnu.org/software/bash/manual/html_node/Programmable-Completion-Builtins.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;complete 명령 안내(KOR)
    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;https://mug896.github.io/bash-shell/command_completion.html&quot;&gt;https://mug896.github.io/bash-shell/command_completion.html&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 02 Sep 2021 22:00:00 +0900</pubDate>
        <link>http://localhost:4000/documentudy/2021/09/02/bash-completion/</link>
        <guid isPermaLink="true">http://localhost:4000/documentudy/2021/09/02/bash-completion/</guid>
        
        <category>UNIX</category>
        
        <category>Bash</category>
        
        <category>Shell</category>
        
        
        <category>Shell</category>
        
      </item>
    
      <item>
        <title>All That Stream</title>
        <description>&lt;ul id=&quot;markdown-toc&quot;&gt;
  &lt;li&gt;&lt;a href=&quot;#1-what-is-stream&quot; id=&quot;markdown-toc-1-what-is-stream&quot;&gt;1. What is Stream&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#11-stream-과-file&quot; id=&quot;markdown-toc-11-stream-과-file&quot;&gt;1.1. Stream 과 File&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#2-standard-stream-표준-스트림&quot; id=&quot;markdown-toc-2-standard-stream-표준-스트림&quot;&gt;2. Standard Stream (표준 스트림)&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#21-standard-streams-stdin--stdout-stderr&quot; id=&quot;markdown-toc-21-standard-streams-stdin--stdout-stderr&quot;&gt;2.1. Standard Streams: &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#22-shell-io-redirect-와-pipe-의-차이&quot; id=&quot;markdown-toc-22-shell-io-redirect-와-pipe-의-차이&quot;&gt;2.2. Shell I/O Redirect 와 PIPE 의 차이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#23--21-이해하기&quot; id=&quot;markdown-toc-23--21-이해하기&quot;&gt;2.3.  &lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 이해하기&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;#3-stream-with-c-language&quot; id=&quot;markdown-toc-3-stream-with-c-language&quot;&gt;3. Stream with C language&lt;/a&gt;    &lt;ul&gt;
      &lt;li&gt;&lt;a href=&quot;#fopen-open-의-차이&quot; id=&quot;markdown-toc-fopen-open-의-차이&quot;&gt;fopen(), open() 의 차이&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;&lt;a href=&quot;#file-pointer-vs-file-descripter&quot; id=&quot;markdown-toc-file-pointer-vs-file-descripter&quot;&gt;file pointer vs file descripter&lt;/a&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;1-what-is-stream&quot;&gt;1. What is Stream&lt;/h1&gt;

&lt;p&gt;UNIX에서는 모든것이 file이다. 그래서 UNIX 에서 strem에 대한 이해가 중요하다. Stream을 사용하는것은 UNIX 응용프로그램에서 파일을 읽고 쓰기 위한 일반적인 방법이기 때문이다.&lt;/p&gt;

&lt;h2 id=&quot;11-stream-과-file&quot;&gt;1.1. Stream 과 File&lt;/h2&gt;

&lt;p&gt;우선 file과 stream의 차이에 대해 알아보자. file은 바이트의 연속적인 모음이다(sequences of bytes). stream은 이 bytes를 입출력하기 위한 인터페이스이자 도구이다. stream은 file뿐만 아니라 socket, keyboard, USB port, printer등 sequential data 로 이루어진 데이터를 다루기 위한 common 인터페이스인데, 이 하나의 인터페이스로 모든 소스를 다룰 수 있다. 모든 소스를 단일한 인터페이스로 다룰 수 있기 때문에 동일한 코드로 위에 나열된 장치들을 모두 file로 여기고 읽고 쓸수 있게 된다. 다시말하지만 UNIX에서는 모든것이 file이다.&lt;/p&gt;

&lt;p&gt;stream은 모든 입력 출력을 바이트의 흐름으로 생각하는것이다. 입출력 장치, 하드웨어, 단말에 상관없이 프로그램을 작성할수 있는 독립성을 갖는다. 이를 장치독립성이라고 한다.  그리고 입출력장치와 CPU의 속도차이를 보완하기 위해서 버퍼를 갖는다.&lt;/p&gt;

&lt;p&gt;아직 Stream의 정체가 무엇인지 매우 추상적이고 모호하다. 그렇다면 물리적으로 Stream은 어떻게 표현될까?  C언어에서 Standard Library 함수인 &lt;code class=&quot;highlighter-rouge&quot;&gt;fopen()&lt;/code&gt; 을 사용해 file을 열어보면, 해당 함수는 &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE *&lt;/code&gt; 이라는 &lt;code class=&quot;highlighter-rouge&quot;&gt;struct FILE&lt;/code&gt;의 포인터 타입을 리턴한다. 이것이 Stream이다. file stream. &lt;code class=&quot;highlighter-rouge&quot;&gt;FILE *&lt;/code&gt; 포인터는 실제 파일을 가리키는 포인터가 아니다. 파일의 스트림을 가리키는 포인터이다. 그리고 그 스트림에는 파일에 대한 여러가지 정보가 담겨있다.&lt;/p&gt;

&lt;p&gt;stream에는 standard stream이 있는데 이것도 결국 file 에 대한 stream이다.  모두 file descriptor 번호를 가지고 있다. standard stream은 프로그램이 실행되면 OS에서 자동으로 생성한다 (stdin/stdout/stderr). stdin 은 FILE * 타입으로 stdio.h 에 정의되어있다. 자세한 내용은 챕터 2에서 다시 설명한다.&lt;/p&gt;

&lt;p&gt;vi나 nano같은 에디터로 파일을 열면 에디터 프로그램은 해당 파일의 스트림을 생성하고 읽고 쓴다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;references
    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/38652953/what-does-stream-mean-in-c&quot;&gt;stackoverflow: what-does-stream-mean-in-c&lt;/a&gt;
&lt;a href=&quot;https://youtu.be/iuEdJ9wg8wU&quot;&gt;youtube: 스트림 (널널한 교수의 기초 C언어) ft. C 코딩&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;2-standard-stream-표준-스트림&quot;&gt;2. Standard Stream (표준 스트림)&lt;/h1&gt;

&lt;h2 id=&quot;21-standard-streams-stdin--stdout-stderr&quot;&gt;2.1. Standard Streams: &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;프로그래머가 생성하지 않아도 자동으로 생성되는 스트림. 모든 Process에 각각 생성된다. 프로그램이 실행되면 운영체제는 실행되는 프로그램(프로세스)에게 3개의 기본 file descripter 를 할당해준다. 번호는 &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt;:0 , &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;:1 , &lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt;:2. 그리고 만약 프로그램이 내부에서 다른 파일을 open() 하게 되면 운영체제는 해당 프로세스에게 3번 file descripter를 할당한다.   &lt;code class=&quot;highlighter-rouge&quot;&gt;stdin&lt;/code&gt; , &lt;code class=&quot;highlighter-rouge&quot;&gt;stdout&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;stderr&lt;/code&gt; 모두 FILE * 타입으로 stdio.h 에 정의되어있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;the OS gives the address to the standard stream made for a process to it automatically.&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Standard stream 은 Unix C runtime environment 에서 환경을 제공한다.
Since Unix provided standard streams, the &lt;strong&gt;Unix C runtime environment&lt;/strong&gt; was obliged to support it as well. As a result, most C runtime environments (and C’s descendants), regardless of the operating system, provide equivalent functionality.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;references
    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/38652953/what-does-stream-mean-in-c&quot;&gt;https://stackoverflow.com/questions/38652953/what-does-stream-mean-in-c&lt;/a&gt;
&lt;a href=&quot;https://blogger.pe.kr/369&quot;&gt;https://blogger.pe.kr/369&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;22-shell-io-redirect-와-pipe-의-차이&quot;&gt;2.2. Shell I/O Redirect 와 PIPE 의 차이&lt;/h2&gt;

&lt;p&gt;일반적으로 UNIX shell은 stdout으로 전달된 것을 console로 출력해준다. 그런데 shell 에서 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 를 사용하면 stdout을 console이 아닌 파일에 출력할 수 있다(stdout to the file). 가령 아래와 같이 ` echo “a b c d”`의 stdout 이 console로 출력되지 않고 tmp.txt 파일로 출력된다. 즉 tmp.txt 파일에 써진다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;a b c d&quot;&lt;/span&gt; &amp;gt; tmp.txt
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;cat tmp.txt 
a b c d
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;1&amp;gt;&lt;/code&gt; 기본적으로 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; 와 동일 fd 1번인 stdout 을 stdout으로 redirect. 문법은 file_descriptor &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; file_name&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&lt;/code&gt; fd 2번인 2번 stream. 즉 stderr를 stdout으로 redirect.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;gt;&lt;/code&gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;gt;name&lt;/code&gt; 은 &lt;code class=&quot;highlighter-rouge&quot;&gt;1&amp;gt;name 2&amp;gt;name&lt;/code&gt; 와 같다. 하지만 name을 두번 open하기 때문에 좋지 않다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 아래 에서 따로 설명한다. 결론적으로 stderr를 stdout으로 지정하는의미.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;반면 pipe &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; 는 stdout을 다른 프로그램의 stdin으로 사용할 수 있다. pipe는 
아래와 같이 실행하면 ` cat tmp.txt&lt;code class=&quot;highlighter-rouge&quot;&gt; 의 stdout 출력결과가 &lt;/code&gt;wc -w&lt;code class=&quot;highlighter-rouge&quot;&gt; 의 stdin으로 입력된다. tmp.txt에 a b c d 즉 4개의 word가 있기때문에 &lt;/code&gt;wc -w`하면 4가 출력된다.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;cat tmp.txt | wc -w
4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;한편 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; 를 사용하면 keyboard가 아닌 &amp;lt; 다음 입력된 파일로 부터 stdin 입력된다.  순서는 딱히 상관 없음.&lt;/p&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt;wc -w &amp;lt; tmp.txt
4
 &lt;span class=&quot;nv&quot;&gt;$ &lt;/span&gt; &amp;lt; tmp.txt wc -w
4
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt; &lt;/th&gt;
      &lt;th&gt;요약&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; file&lt;/td&gt;
      &lt;td&gt;stdout을 console 이 아닌 file에 출력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&lt;/code&gt; file&lt;/td&gt;
      &lt;td&gt;keyboard가 아닌 file로 부터 stdin 입력&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;cmd1 &lt;code class=&quot;highlighter-rouge&quot;&gt;|&lt;/code&gt; cmd2&lt;/td&gt;
      &lt;td&gt;한 프로그램(cmd1)의 stdout출력을 다음 프로그램(cmd2)의 stdin 으로 사용&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;references
    &lt;blockquote&gt;
      &lt;p&gt;&lt;a href=&quot;https://thoughtbot.com/blog/input-output-redirection-in-the-shell&quot;&gt;https://thoughtbot.com/blog/input-output-redirection-in-the-shell&lt;/a&gt;
&lt;a href=&quot;https://github.com/kennyyu/bootcamp-unix/wiki/stdin,-stdout,-stderr,-and-pipes&quot;&gt;https://github.com/kennyyu/bootcamp-unix/wiki/stdin,-stdout,-stderr,-and-pipes&lt;/a&gt;&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;23--21-이해하기&quot;&gt;2.3.  &lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 이해하기&lt;/h2&gt;
&lt;p&gt;Shell 에서 error 메시지를 없앨때 빈번히 사용하는 표현이다. &lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&lt;/code&gt; 는 stderr을 stdout으로 redirect. &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;1&lt;/code&gt; 는 이전에 지정한 stdout이 출력하는 파일을 의미한다고 생각하면 쉽다. 엄밀히 말하면 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;연산자 대신에 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;amp;&lt;/code&gt; 를 사용한것이다.  &lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt; 이전에 fd번호 1을 다른 파일로 재지정 했다면, fd번호 2는 재지정한 stdout으로  redirect 한다는 의미.&lt;/p&gt;

&lt;p&gt;예를들어, &lt;code class=&quot;highlighter-rouge&quot;&gt;cat asdf.txt&lt;/code&gt; 이 아래와 같이 에러메시지를 출력한다고 해보자.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ cat asdf.txt
cat: asdf.txt: No such file or directory
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;cat asdf.txt &amp;gt; /dev/null 2&amp;gt;&amp;amp;1&lt;/code&gt; 을 수행하면 먼저 stdout은 /dev/null 로 redirect되고, 그 뒤 &lt;code class=&quot;highlighter-rouge&quot;&gt;2&amp;gt;&amp;amp;1&lt;/code&gt;을 통해 stderr는 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;1&lt;/code&gt;로 redirect된다. 즉 stderr도 /dev/null로 redirect되는것이다. 따라서 console에는 아무것도 출력되지 않는다.&lt;/p&gt;

&lt;p&gt;그런데 만약 &lt;code class=&quot;highlighter-rouge&quot;&gt;cat asdf.txt 2&amp;gt;&amp;amp;1&lt;/code&gt;을 하면 어떻게 될까? stdout 을 따로 지정하지 않았기 때문에 &amp;amp;1 는 default인 console이다. 따라서 2&amp;gt; 즉 stderr 는 그대로 console에 출력된다.&lt;/p&gt;

&lt;p&gt;관련해서 구체적인 문법은 아래와 같다. 두번째 항목을 보면된다. &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;amp;&lt;/code&gt; 연산자의 우측에는 file descriptor 번호가 오는것.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt;
file_descriptor &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&lt;/code&gt; file_name&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;amp;&lt;/code&gt; 
file_descriptor &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;gt;&amp;amp;&lt;/code&gt; file_descriptor&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;gt;&lt;/code&gt;
&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;amp;&amp;gt;&lt;/code&gt; file_name&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;3-stream-with-c-language&quot;&gt;3. Stream with C language&lt;/h1&gt;

&lt;h2 id=&quot;fopen-open-의-차이&quot;&gt;fopen(), open() 의 차이&lt;/h2&gt;
&lt;p&gt;가장 큰 차이는 &lt;code class=&quot;highlighter-rouge&quot;&gt;fopen()&lt;/code&gt; 은 Standard Library이고, &lt;code class=&quot;highlighter-rouge&quot;&gt;open()&lt;/code&gt;은  UNIX System Call이라는 점이다.
 fopen은 내부적으로 open을 사용한다. fopen은 버퍼를 사용하기 때문에 빈번한 system call 을 방지해준다. 잦은 system call은 성능 저하를 발생시킬 수 있다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;struct FILE 구조체&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-c highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nl&quot;&gt;c:&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;linenumbers&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;wraptext&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;typedef&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;strut&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;_iobuf&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cnt&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;cm&quot;&gt;/* characters left */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;      &lt;span class=&quot;cm&quot;&gt;/* next character position */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;base&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;     &lt;span class=&quot;cm&quot;&gt;/* location of buffer */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;flag&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;cm&quot;&gt;/* mode of file access */&lt;/span&gt;
        &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fd&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;cm&quot;&gt;/* file descriptor */&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;FILE&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;from K&amp;amp;R (C Programming Language,  ANSI C, p.176)&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;file-pointer-vs-file-descripter&quot;&gt;file pointer vs file descripter&lt;/h2&gt;
</description>
        <pubDate>Tue, 31 Aug 2021 22:00:00 +0900</pubDate>
        <link>http://localhost:4000/documentudy/2021/08/31/UNIX-understanding-file-stream/</link>
        <guid isPermaLink="true">http://localhost:4000/documentudy/2021/08/31/UNIX-understanding-file-stream/</guid>
        
        <category>UNIX</category>
        
        <category>C</category>
        
        <category>Shell</category>
        
        
        <category>UNIX</category>
        
      </item>
    
  </channel>
</rss>
